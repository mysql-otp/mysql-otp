<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>Module mysql</title>
<link rel="stylesheet" type="text/css" href="stylesheet.css" title="EDoc">
</head>
<body bgcolor="white">
<div class="navbar"><a name="#navbar_top"></a><table width="100%" border="0" cellspacing="0" cellpadding="2" summary="navigation bar"><tr><td><a href="overview-summary.html" target="overviewFrame">Overview</a></td><td><a href="http://www.erlang.org/"><img src="erlang.png" align="right" border="0" alt="erlang logo"></a></td></tr></table></div>
<hr>

<h1>Module mysql</h1>
<ul class="index"><li><a href="#description">Description</a></li><li><a href="#types">Data Types</a></li><li><a href="#index">Function Index</a></li><li><a href="#functions">Function Details</a></li></ul>MySQL client.

<p><b>Behaviours:</b> <a href="gen_server.html"><tt>gen_server</tt></a>.</p>

<h2><a name="description">Description</a></h2><p>MySQL client.</p>
 
  The <code>connection()</code> type is a gen_server reference as described in the
  documentation for <code>gen_server:call/2,3</code>, e.g. the pid or the name if the
  gen_server is locally registered.
<h2><a name="types">Data Types</a></h2>

<h3 class="typedecl"><a name="type-column_names">column_names()</a></h3>
<p><tt>column_names() = [binary()]</tt></p>


<h3 class="typedecl"><a name="type-connection">connection()</a></h3>
<p><tt>connection() = atom() | {Name::atom(), Node::atom()} | {global, GlobalName::term()} | {via, Module::atom(), ViaName::term()} | pid()</tt></p>


<h3 class="typedecl"><a name="type-query_result">query_result()</a></h3>
<p><tt>query_result() = ok | {ok, <a href="#type-column_names">column_names()</a>, <a href="#type-rows">rows()</a>} | {ok, [{<a href="#type-column_names">column_names()</a>, <a href="#type-rows">rows()</a>}, ...]} | {error, <a href="#type-server_reason">server_reason()</a>}</tt></p>


<h3 class="typedecl"><a name="type-rows">rows()</a></h3>
<p><tt>rows() = [[term()]]</tt></p>


<h3 class="typedecl"><a name="type-server_reason">server_reason()</a></h3>
<p><tt>server_reason() = {Code::integer(), SQLState::binary(), Message::binary()}</tt></p>


<h2><a name="index">Function Index</a></h2>
<table width="100%" border="1" cellspacing="0" cellpadding="2" summary="function index"><tr><td valign="top"><a href="#affected_rows-1">affected_rows/1</a></td><td>Returns the number of inserted, updated and deleted rows of the last
  executed query or prepared statement.</td></tr>
<tr><td valign="top"><a href="#autocommit-1">autocommit/1</a></td><td>Returns true if auto-commit is enabled and false otherwise.</td></tr>
<tr><td valign="top"><a href="#encode-2">encode/2</a></td><td>Encodes a term as a MySQL literal so that it can be used to inside a  
query.</td></tr>
<tr><td valign="top"><a href="#execute-3">execute/3</a></td><td>Executes a prepared statement with the default query timeout as given
  to start_link/1.</td></tr>
<tr><td valign="top"><a href="#execute-4">execute/4</a></td><td>Executes a prepared statement.</td></tr>
<tr><td valign="top"><a href="#in_transaction-1">in_transaction/1</a></td><td>Returns true if the connection is in a transaction and false otherwise.</td></tr>
<tr><td valign="top"><a href="#insert_id-1">insert_id/1</a></td><td>Returns the last insert-id.</td></tr>
<tr><td valign="top"><a href="#prepare-2">prepare/2</a></td><td>Creates a prepared statement from the passed query.</td></tr>
<tr><td valign="top"><a href="#prepare-3">prepare/3</a></td><td>Creates a prepared statement from the passed query and associates it
  with the given name.</td></tr>
<tr><td valign="top"><a href="#query-2">query/2</a></td><td>Executes a query with the query timeout as given to start_link/1.</td></tr>
<tr><td valign="top"><a href="#query-3">query/3</a></td><td>Depending on the 3rd argument this function does different things.</td></tr>
<tr><td valign="top"><a href="#query-4">query/4</a></td><td>Executes a parameterized query with a timeout.</td></tr>
<tr><td valign="top"><a href="#start_link-1">start_link/1</a></td><td>Starts a connection gen_server process and connects to a database.</td></tr>
<tr><td valign="top"><a href="#transaction-2">transaction/2</a></td><td>This function executes the functional object Fun as a transaction.</td></tr>
<tr><td valign="top"><a href="#transaction-3">transaction/3</a></td><td>This function executes the functional object Fun as a transaction.</td></tr>
<tr><td valign="top"><a href="#transaction-4">transaction/4</a></td><td>This function executes the functional object Fun with arguments Args as  
a transaction.</td></tr>
<tr><td valign="top"><a href="#unprepare-2">unprepare/2</a></td><td>Deallocates a prepared statement.</td></tr>
<tr><td valign="top"><a href="#warning_count-1">warning_count/1</a></td><td>Returns the number of warnings generated by the last query/2 or
  execute/3 calls.</td></tr>
</table>

<h2><a name="functions">Function Details</a></h2>

<h3 class="function"><a name="affected_rows-1">affected_rows/1</a></h3>
<div class="spec">
<p><tt>affected_rows(Conn::<a href="#type-connection">connection()</a>) -&gt; integer()</tt><br></p>
</div><p>Returns the number of inserted, updated and deleted rows of the last
  executed query or prepared statement.</p>

<h3 class="function"><a name="autocommit-1">autocommit/1</a></h3>
<div class="spec">
<p><tt>autocommit(Conn::<a href="#type-connection">connection()</a>) -&gt; boolean()</tt><br></p>
</div><p>Returns true if auto-commit is enabled and false otherwise.</p>

<h3 class="function"><a name="encode-2">encode/2</a></h3>
<div class="spec">
<p><tt>encode(Conn::<a href="#type-connection">connection()</a>, Term::term()) -&gt; iodata()</tt><br></p>
</div><p><p>Encodes a term as a MySQL literal so that it can be used to inside a  
query. If backslash escapes are enabled, backslashes and single quotes in  
strings and binaries are escaped. Otherwise only single quotes are escaped.</p>
 
  Note that the preferred way of sending values is by prepared statements or
  parametrized queries with placeholders.
 </p>
<p><b>See also:</b> <a href="#execute-3">execute/3</a>, <a href="#query-3">query/3</a>.</p>

<h3 class="function"><a name="execute-3">execute/3</a></h3>
<div class="spec">
<p><tt>execute(Conn, StatementRef, Params) -&gt; Result | {error, not_prepared}</tt>
<ul class="definitions"><li><tt>Conn = <a href="#type-connection">connection()</a></tt></li><li><tt>StatementRef = atom() | integer()</tt></li><li><tt>Params = [term()]</tt></li><li><tt>Result = <a href="#type-query_result">query_result()</a></tt></li></ul></p>
</div><p>Executes a prepared statement with the default query timeout as given
  to start_link/1.</p>
<p><b>See also:</b> <a href="#prepare-2">prepare/2</a>, <a href="#prepare-3">prepare/3</a>.</p>

<h3 class="function"><a name="execute-4">execute/4</a></h3>
<div class="spec">
<p><tt>execute(Conn, StatementRef, Params, Timeout) -&gt; Result | {error, not_prepared}</tt>
<ul class="definitions"><li><tt>Conn = <a href="#type-connection">connection()</a></tt></li><li><tt>StatementRef = atom() | integer()</tt></li><li><tt>Params = [term()]</tt></li><li><tt>Timeout = timeout()</tt></li><li><tt>Result = <a href="#type-query_result">query_result()</a></tt></li></ul></p>
</div><p>Executes a prepared statement.</p>
<p><b>See also:</b> <a href="#prepare-2">prepare/2</a>, <a href="#prepare-3">prepare/3</a>.</p>

<h3 class="function"><a name="in_transaction-1">in_transaction/1</a></h3>
<div class="spec">
<p><tt>in_transaction(Conn::<a href="#type-connection">connection()</a>) -&gt; boolean()</tt><br></p>
</div><p>Returns true if the connection is in a transaction and false otherwise.
  This works regardless of whether the transaction has been started using
  transaction/2,3 or using a plain <code>mysql:query(Connection, "START
  TRANSACTION")</code>.</p>
<p><b>See also:</b> <a href="#transaction-2">transaction/2</a>, <a href="#transaction-4">transaction/4</a>.</p>

<h3 class="function"><a name="insert_id-1">insert_id/1</a></h3>
<div class="spec">
<p><tt>insert_id(Conn::<a href="#type-connection">connection()</a>) -&gt; integer()</tt><br></p>
</div><p>Returns the last insert-id.</p>

<h3 class="function"><a name="prepare-2">prepare/2</a></h3>
<div class="spec">
<p><tt>prepare(Conn, Query) -&gt; {ok, StatementId} | {error, Reason}</tt>
<ul class="definitions"><li><tt>Conn = <a href="#type-connection">connection()</a></tt></li><li><tt>Query = iodata()</tt></li><li><tt>StatementId = integer()</tt></li><li><tt>Reason = <a href="#type-server_reason">server_reason()</a></tt></li></ul></p>
</div><p>Creates a prepared statement from the passed query.</p>
<p><b>See also:</b> <a href="#prepare-3">prepare/3</a>.</p>

<h3 class="function"><a name="prepare-3">prepare/3</a></h3>
<div class="spec">
<p><tt>prepare(Conn, Name, Query) -&gt; {ok, Name} | {error, Reason}</tt>
<ul class="definitions"><li><tt>Conn = <a href="#type-connection">connection()</a></tt></li><li><tt>Name = atom()</tt></li><li><tt>Query = iodata()</tt></li><li><tt>Reason = <a href="#type-server_reason">server_reason()</a></tt></li></ul></p>
</div><p>Creates a prepared statement from the passed query and associates it
  with the given name.</p>
<p><b>See also:</b> <a href="#prepare-2">prepare/2</a>.</p>

<h3 class="function"><a name="query-2">query/2</a></h3>
<div class="spec">
<p><tt>query(Conn, Query) -&gt; Result</tt>
<ul class="definitions"><li><tt>Conn = <a href="#type-connection">connection()</a></tt></li><li><tt>Query = iodata()</tt></li><li><tt>Result = <a href="#type-query_result">query_result()</a></tt></li></ul></p>
</div><p><p>Executes a query with the query timeout as given to start_link/1.</p>
 
  <p>It is possible to execute multiple semicolon-separated queries.</p>
 
  <p>Results are returned in the form <code>{ok, ColumnNames, Rows}</code> if there is one
  result set. If there are more than one result sets, they are returned in the
  form <code>{ok, [{ColumnNames, Rows}, ...]}</code>.</p>
 
  For queries that don't return any rows (INSERT, UPDATE, etc.) only the atom
  <code>ok</code> is returned.</p>

<h3 class="function"><a name="query-3">query/3</a></h3>
<div class="spec">
<p><tt>query(Conn, Query, Params::Params | Timeout) -&gt; Result</tt>
<ul class="definitions"><li><tt>Conn = <a href="#type-connection">connection()</a></tt></li><li><tt>Query = iodata()</tt></li><li><tt>Timeout = timeout()</tt></li><li><tt>Params = [term()]</tt></li><li><tt>Result = <a href="#type-query_result">query_result()</a></tt></li></ul></p>
</div><p><p>Depending on the 3rd argument this function does different things.</p>
 
  <p>If the 3rd argument is a list, it executes a parameterized query. This is  
equivallent to query/4 with the query timeout as given to start_link/1.</p>
 
  <p>If the 3rd argument is a timeout, it executes a plain query with this  
timeout.</p>
 
  The return value is the same as for query/2.
 </p>
<p><b>See also:</b> <a href="#query-2">query/2</a>, <a href="#query-4">query/4</a>.</p>

<h3 class="function"><a name="query-4">query/4</a></h3>
<div class="spec">
<p><tt>query(Conn, Query, Params, Timeout) -&gt; Result</tt>
<ul class="definitions"><li><tt>Conn = <a href="#type-connection">connection()</a></tt></li><li><tt>Query = iodata()</tt></li><li><tt>Timeout = timeout()</tt></li><li><tt>Params = [term()]</tt></li><li><tt>Result = <a href="#type-query_result">query_result()</a></tt></li></ul></p>
</div><p><p>Executes a parameterized query with a timeout.</p>
 
  <p>A prepared statement is created, executed and then cached for a certain  
time. If the same query is executed again when it is already cached, it does  
not need to be prepared again.</p>
 
  <p>The minimum time the prepared statement is cached can be specified using the
  option <code>{query_cache_time, Milliseconds}</code> to start_link/1.</p>
 
  The return value is the same as for query/2.</p>

<h3 class="function"><a name="start_link-1">start_link/1</a></h3>
<div class="spec">
<p><tt>start_link(Options) -&gt; {ok, pid()} | ignore | {error, term()}</tt>
<ul class="definitions"><li><tt>Options = [Option]</tt></li><li><tt>Option = {name, ServerName} | {host, iodata()} | {port, integer()} | {user, iodata()} | {password, iodata()} | {database, iodata()} | {connect_timeout, timeout()} | {log_warnings, boolean()} | {keep_alive, boolean() | timeout()} | {prepare, NamedStatements} | {queries, [iodata()]} | {query_timeout, timeout()} | {query_cache_time, non_neg_integer()}</tt></li><li><tt>ServerName = {local, Name::atom()} | {global, GlobalName::term()} | {via, Module::atom(), ViaName::term()}</tt></li><li><tt>NamedStatements = [{StatementName::atom(), Statement::iodata()}]</tt></li></ul></p>
</div><p><p>Starts a connection gen_server process and connects to a database. To
  disconnect just do <code>exit(Pid, normal)</code>.</p>
 
  <p>Options:</p>
 
  <dl>
    <dt><code>{name, ServerName}</code></dt>
    <dd>If a name is provided, the gen_server will be registered with this
        name. For details see the documentation for the first argument of
        gen_server:start_link/4.</dd>
    <dt><code>{host, Host}</code></dt>
    <dd>Hostname of the MySQL database; default <code>"localhost"</code>.</dd>
    <dt><code>{port, Port}</code></dt>
    <dd>Port; default 3306 if omitted.</dd>
    <dt><code>{user, User}</code></dt>
    <dd>Username.</dd>
    <dt><code>{password, Password}</code></dt>
    <dd>Password.</dd>
    <dt><code>{database, Database}</code></dt>
    <dd>The name of the database AKA schema to use. This can be changed later
        using the query <code>USE &lt;database&gt;</code>.</dd>
    <dt><code>{connect_timeout, Timeout}</code></dt>
    <dd>The maximum time to spend for start_link/1.</dd>
    <dt><code>{log_warnings, boolean()}</code></dt>
    <dd>Whether to fetch warnings and log them using error_logger; default
        true.</dd>
    <dt><code>{keep_alive, boolean() | timeout()}</code></dt>
    <dd>Send ping when unused for a certain time. Possible values are <code>true</code>,
        <code>false</code> and <code>integer() &gt; 0</code> for an explicit interval in milliseconds.
        The default is <code>false</code>. For <code>true</code> a default ping timeout is used.
        </dd>
    <dt><code>{prepare, NamedStatements}</code></dt>
    <dd>Named prepared statements to be created as soon as the connection is
        ready.</dd>
    <dt><code>{queries, Queries}</code></dt>
    <dd>Queries to be executed as soon as the connection is ready. Any results
        are discarded. Typically, this is used for setting time zone and other
        session variables.</dd>
    <dt><code>{query_timeout, Timeout}</code></dt>
    <dd>The default time to wait for a response when executing a query or a
        prepared statement. This can be given per query using <code>query/3,4</code> and
        <code>execute/4</code>. The default is <code>infinity</code>.</dd>
    <dt><code>{query_cache_time, Timeout}</code></dt>
    <dd>The minimum number of milliseconds to cache prepared statements used
        for parametrized queries with query/3.</dd>
    <dt><code>{tcp_options, Options}</code></dt>
    <dd>Additional options for <code>gen_tcp:connect/3</code>. You may want to set
        <code>{recbuf, Size}</code> and <code>{sndbuf, Size}</code> if you send or receive more than
        the default (typically 8K) per query.</dd>
  </dl></p>

<h3 class="function"><a name="transaction-2">transaction/2</a></h3>
<div class="spec">
<p><tt>transaction(Conn::<a href="#type-connection">connection()</a>, Fun::function()) -&gt; {atomic, term()} | {aborted, term()}</tt><br></p>
</div><p>This function executes the functional object Fun as a transaction.</p>
<p><b>See also:</b> <a href="#transaction-4">transaction/4</a>.</p>

<h3 class="function"><a name="transaction-3">transaction/3</a></h3>
<div class="spec">
<p><tt>transaction(Conn::<a href="#type-connection">connection()</a>, Fun::function(), Retries) -&gt; {atomic, term()} | {aborted, term()}</tt>
<ul class="definitions"><li><tt>Retries = non_neg_integer() | infinity</tt></li></ul></p>
</div><p>This function executes the functional object Fun as a transaction.</p>
<p><b>See also:</b> <a href="#transaction-4">transaction/4</a>.</p>

<h3 class="function"><a name="transaction-4">transaction/4</a></h3>
<div class="spec">
<p><tt>transaction(Conn::<a href="#type-connection">connection()</a>, Fun::function(), Args::list(), Retries) -&gt; {atomic, term()} | {aborted, term()}</tt>
<ul class="definitions"><li><tt>Retries = non_neg_integer() | infinity</tt></li></ul></p>
</div><p><p>This function executes the functional object Fun with arguments Args as  
a transaction.</p>
 
  <p>The semantics are as close as possible to mnesia's transactions. Transactions  
can be nested and are restarted automatically when deadlocks are detected.  
MySQL's savepoints are used to implement nested transactions.</p>
 
  <p>Fun must be a function and Args must be a list of the same length as the  
arity of Fun.</p>
 
  <p>If an exception occurs within Fun, the exception is caught and <code>{aborted,
  Reason}</code> is returned. The value of <code>Reason</code> depends on the class of the  
exception.</p>
 
  <p>Note that an error response from a query does not cause a transaction to be
  rollbacked. To force a rollback on a MySQL error you can trigger a <code>badmatch</code>
  using e.g. <code>ok = mysql:query(Pid, "SELECT some_non_existent_value")</code>.  
Exceptions to this are error 1213 "Deadlock" (after the specified number  
retries all have failed) and error 1205 "Lock wait timeout" which causes an  
*implicit rollback*.</p>
 
  <p>Some queries such as ALTER TABLE cause an *implicit commit* on the server.
  If such a query is executed within a transaction, an error on the form
  <code>{implicit_commit, Query}</code> is raised. This means that the transaction has  
been committed prematurely. This also happens if an explicit COMMIT is  
executed as a plain query within a managed transaction. (Don't do that!)</p>
 
  <table>
    <thead>
      <tr><th>Class of exception</th><th>Return value</th></tr>
    </thead>
    <tbody>
      <tr>
        <td><code>error</code> with reason <code>ErrorReason</code></td>
        <td><code>{aborted, {ErrorReason, Stack}}</code></td>
      </tr>
      <tr><td><code>exit(Term)</code></td><td><code>{aborted, Term}</code></td></tr>
      <tr><td><code>throw(Term)</code></td><td><code>{aborted, {throw, Term}}</code></td></tr>
    </tbody>
  </table></p>

<h3 class="function"><a name="unprepare-2">unprepare/2</a></h3>
<div class="spec">
<p><tt>unprepare(Conn, StatementRef) -&gt; ok | {error, Reason}</tt>
<ul class="definitions"><li><tt>Conn = <a href="#type-connection">connection()</a></tt></li><li><tt>StatementRef = atom() | integer()</tt></li><li><tt>Reason = <a href="#type-server_reason">server_reason()</a> | not_prepared</tt></li></ul></p>
</div><p>Deallocates a prepared statement.</p>

<h3 class="function"><a name="warning_count-1">warning_count/1</a></h3>
<div class="spec">
<p><tt>warning_count(Conn::<a href="#type-connection">connection()</a>) -&gt; integer()</tt><br></p>
</div><p>Returns the number of warnings generated by the last query/2 or
  execute/3 calls.</p>
<hr>

<div class="navbar"><a name="#navbar_bottom"></a><table width="100%" border="0" cellspacing="0" cellpadding="2" summary="navigation bar"><tr><td><a href="overview-summary.html" target="overviewFrame">Overview</a></td><td><a href="http://www.erlang.org/"><img src="erlang.png" align="right" border="0" alt="erlang logo"></a></td></tr></table></div>
<p><i>Generated by EDoc, Jul 1 2016, 15:51:22.</i></p>
</body>
</html>
